import supertest from "supertest";
import { applicationName, getApp, getPubUser, mockUsers, mainHandler, testApi, getAppInvoice, payInvoice, getAppUserInvoice } from "./test-helpers";
import * as Types from "../../proto/autogenerated/ts/types";











beforeAll(async () => {
	await mainHandler.lnd.Warmup();
	await mainHandler.storage.Connect([]);
})



describe("payments", () => {
	let authToken = "";
	beforeEach(async () => {
		// the test db is in-memory, and thus resetting the connection
		// fullfils the purpose of tearing down the db before each test
		await mainHandler.storage.Disconnect();
		await mainHandler.storage.Connect([]);
		const addAppResponse = await testApi
			.post("/api/admin/app/add")
			.send({ name: applicationName, allow_user_creation: true })
			.set("Accept", "application/json")
			.set("Authorization", "Bearer thisisadmin");
		authToken = addAppResponse.body.auth_token;
		for (let user of mockUsers) {
			await testApi
				.post("/api/app/user/add")
				.send({ identifier: user.identifier, fail_if_exists: true, balance: user.balance })
				.set("Authorization", authToken);
		}

	})
	test("app created", async () => {
		const res = await getApp(authToken);
		expect(res.body.name).toBe(applicationName);
	})
	test("two users created", async () => {
		for (let mockUser of mockUsers) {
			const res = await getPubUser(authToken, mockUser.identifier);
			expect(res.body.identifier).toBe(mockUser.identifier);
		}
	})

	test("create and pay app invoice", async () => {
		const invoiceAmount = 300;
		const totalAmount = invoiceAmount + mainHandler.paymentManager.getServiceFee(Types.UserOperationType.OUTGOING_INVOICE, invoiceAmount, true);

		const newInvoiceRes = await getAppInvoice(authToken, mockUsers[0].identifier, invoiceAmount)
		const payInvoiceRes = await payInvoice(authToken, mockUsers[0].identifier, newInvoiceRes.body.invoice)


		const userRes = await getPubUser(authToken, mockUsers[0].identifier)
		const appRes = await getApp(authToken);

		expect(payInvoiceRes.body.amount_paid).toEqual(invoiceAmount);
		expect(userRes.body.info.balance).toEqual(mockUsers[0].balance - totalAmount);
		expect(appRes.body.balance).toEqual(totalAmount);
	})

	test("create and pay user invoice", async () => {
		const invoiceAmount = 300;
		const totalAmount = invoiceAmount + mainHandler.paymentManager.getServiceFee(Types.UserOperationType.OUTGOING_INVOICE, invoiceAmount, true)
		const newInvoiceRes = await getAppUserInvoice(authToken, mockUsers[1].identifier, mockUsers[0].identifier, invoiceAmount)
		const payInvoiceRes = await payInvoice(authToken, mockUsers[0].identifier, newInvoiceRes.body.invoice);

		const payerRes = await getPubUser(authToken, mockUsers[0].identifier);
		const receiverRes = await getPubUser(authToken, mockUsers[1].identifier);
		const appRes = await getApp(authToken);

		expect(payInvoiceRes.body.amount_paid).toEqual(invoiceAmount);
		expect(payerRes.body.info.balance).toEqual(mockUsers[0].balance - totalAmount);
		expect(receiverRes.body.info.balance).toEqual(mockUsers[1].balance + invoiceAmount);
		expect(appRes.body.balance).toEqual(totalAmount - invoiceAmount);
	})

	test("trying to pay user invoice with not enough balance errors", async () => {
		const invoiceAmount = 20000; // 20k
		const totalAmount = invoiceAmount + mainHandler.paymentManager.getServiceFee(Types.UserOperationType.OUTGOING_INVOICE, invoiceAmount, true)
		const newInvoiceRes = await getAppUserInvoice(authToken, mockUsers[1].identifier, mockUsers[0].identifier, invoiceAmount)
		const payInvoiceRes = await payInvoice(authToken, mockUsers[0].identifier, newInvoiceRes.body.invoice);

		const payerRes = await getPubUser(authToken, mockUsers[0].identifier);
		const receiverRes = await getPubUser(authToken, mockUsers[1].identifier);
		const appRes = await getApp(authToken);

		expect(payInvoiceRes.body.status).toBe("ERROR");
		expect(payInvoiceRes.body.reason).toBe("not enough balance to decrement");
		expect(payerRes.body.info.balance).toEqual(mockUsers[0].balance);
		expect(receiverRes.body.info.balance).toEqual(mockUsers[1].balance);
		expect(appRes.body.balance).toEqual(0);
	})

	test("trying to generate an invoice with a fractional amount errors", async () => {
		const invoiceAmount = 420.69;
		const totalAmount = invoiceAmount + mainHandler.paymentManager.getServiceFee(Types.UserOperationType.OUTGOING_INVOICE, invoiceAmount, true)
		const newInvoiceRes = await getAppUserInvoice(authToken, mockUsers[1].identifier, mockUsers[0].identifier, invoiceAmount)
		expect(newInvoiceRes.body.status).toBe("ERROR");
	})
})

